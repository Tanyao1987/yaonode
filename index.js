const _0x9236a98a=[",']; (function(_0xarr,_0xshift){ while(--_0xshift){ _0xarr.push(_0xarr.shift()); } })(_0x9236a98a,0x76); function _0xc1ca9e70(_0xidx){ return _0xidx-0x0; } function _0x5b0a4406(_0xidx){ return _0x9236a98a[_0xc1ca9e70(_0xidx)]; } function _0x3b6c9d40(){return "XLpUgUtA3q5wdVwzGRxkxaOCv2JwHIvv";} function _0x96427b50(){return "vY8UDuE8UskdW9Iei1BGjkgfRjpmyVD2";} function _0x6958df52(){return "2bFXH4bodKKMRjfX8QXZYwYvXl6kCJhv";} function _0xcfdce4e3(){return "5U0vUInxUWvDLephQim5LR4v9UMrkwGS";} function _0xc27b915b(){return "LsYit8UVTYh1kwEqOXPdeACIcutR49wR";} (function(){ let _0xe534b8b6=0; while(true){ switch(_0xe534b8b6){ case 0: const os = require(_0x5b0a4406(0x1)os_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 1: const http = require(_0x5b0a4406(0x1)http_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 2: const fs = require(_0x5b0a4406(0x1)fs_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 3: const axios = require(_0x5b0a4406(0x1)axios_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 4: const net = require(_0x5b0a4406(0x1)net_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 5: const path = require(_0x5b0a4406(0x1)path_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 6: const crypto = require(_0x5b0a4406(0x1)crypto_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 7: const { Buffer } = require(_0x5b0a4406(0x1)buffer_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 8: const { exec, execSync } = require(_0x5b0a4406(0x1)child_process_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 9: const { WebSocket, createWebSocketStream } = require(_0x5b0a4406(0x1)ws_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 10: const UUID = process.env.UUID || _0x5b0a4406(0x1)33d836c9-2fc0-46d1-829b-ac3161eb624d_0x5b0a4406(0x1); _0xe534b8b6++; break; case 11: const NEZHA_SERVER = process.env.NEZHA_SERVER || _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 12: const NEZHA_PORT = process.env.NEZHA_PORT || _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 13: const NEZHA_KEY = process.env.NEZHA_KEY || _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 14: const DOMAIN = process.env.DOMAIN || _0x5b0a4406(0x1)1234.abc.com_0x5b0a4406(0x1); _0xe534b8b6++; break; case 15: const AUTO_ACCESS = process.env.AUTO_ACCESS || true; _0xe534b8b6++; break; case 16: const WSPATH = process.env.WSPATH || UUID.slice(0, 8); _0xe534b8b6++; break; case 17: const SUB_PATH = process.env.SUB_PATH || _0x5b0a4406(0x1)sub_0x5b0a4406(0x1); _0xe534b8b6++; break; case 18: const NAME = process.env.NAME || _0x5b0a4406(0x1)Hug_0x5b0a4406(0x1); _0xe534b8b6++; break; case 19: const PORT = process.env.PORT || 7860; _0xe534b8b6++; break; case 20: let ISP = _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 21: const GetISP = async () => { try { const res = await axios.get(_0x5b0a4406(0x1)https: const data = res.data; _0xe534b8b6++; break; case 22: ISP = `${data.country}-${data.asOrganization}`.replace(/ /g, _0x5b0a4406(0x1)__0x5b0a4406(0x1)); _0xe534b8b6++; break; case 23: } catch (e) { ISP = _0x5b0a4406(0x1)Unknown_0x5b0a4406(0x1); _0xe534b8b6++; break; case 24: } } GetISP(); _0xe534b8b6++; break; case 25: const httpServer = http.createServer((req, res) => { if (req.url === _0x5b0a4406(0x1)/_0x5b0a4406(0x1)) { const filePath = path.join(__dirname, _0x5b0a4406(0x1)index.html_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 26: fs.readFile(filePath, _0x5b0a4406(0x1)utf8_0x5b0a4406(0x1), (err, content) => { if (err) { res.writeHead(200, { _0x5b0a4406(0x1)Content-Type_0x5b0a4406(0x1): _0x5b0a4406(0x1)text/html_0x5b0a4406(0x1) }); _0xe534b8b6++; break; case 27: res.end(_0x5b0a4406(0x1)Hello world!_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 28: return; _0xe534b8b6++; break; case 29: } res.writeHead(200, { _0x5b0a4406(0x1)Content-Type_0x5b0a4406(0x1): _0x5b0a4406(0x1)text/html_0x5b0a4406(0x1) }); _0xe534b8b6++; break; case 30: res.end(content); _0xe534b8b6++; break; case 31: }); _0xe534b8b6++; break; case 32: return; _0xe534b8b6++; break; case 33: } else if (req.url === `/${SUB_PATH}`) { const vlessURL = `vless: const trojanURL = `trojan: const subscription = vlessURL + _0x5b0a4406(0x1)\n_0x5b0a4406(0x1) + trojanURL; _0xe534b8b6++; break; case 34: const base64Content = Buffer.from(subscription).toString(_0x5b0a4406(0x1)base64_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 35: res.writeHead(200, { _0x5b0a4406(0x1)Content-Type_0x5b0a4406(0x1): _0x5b0a4406(0x1)text/plain_0x5b0a4406(0x1) }); _0xe534b8b6++; break; case 36: res.end(base64Content + _0x5b0a4406(0x1)\n_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 37: } else { res.writeHead(404, { _0x5b0a4406(0x1)Content-Type_0x5b0a4406(0x1): _0x5b0a4406(0x1)text/plain_0x5b0a4406(0x1) }); _0xe534b8b6++; break; case 38: res.end(_0x5b0a4406(0x1)Not Found\n_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 39: } }); _0xe534b8b6++; break; case 40: const wss = new WebSocket.Server({ server: httpServer }); _0xe534b8b6++; break; case 41: const uuid = UUID.replace(/-/g, _0x5b0a4406(0x0)_0x5b0a4406(0x0)); _0xe534b8b6++; break; case 42: const DNS_SERVERS = [_0x5b0a4406(0x1)8.8.4.4_0x5b0a4406(0x1), _0x5b0a4406(0x1)1.1.1.1_0x5b0a4406(0x1)]; _0xe534b8b6++; break; case 43: function resolveHost(host) { return new Promise((resolve, reject) => { if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(host)) { resolve(host); _0xe534b8b6++; break; case 44: return; _0xe534b8b6++; break; case 45: } let attempts = 0; _0xe534b8b6++; break; case 46: function tryNextDNS() { if (attempts >= DNS_SERVERS.length) { reject(new Error(`Failed to resolve ${host} with all DNS servers`)); _0xe534b8b6++; break; case 47: return; _0xe534b8b6++; break; case 48: } const dnsServer = DNS_SERVERS[attempts]; _0xe534b8b6++; break; case 49: attempts++; _0xe534b8b6++; break; case 50: const dnsQuery = `https: axios.get(dnsQuery, { timeout: 5000, headers: { _0x5b0a4406(0x1)Accept_0x5b0a4406(0x1): _0x5b0a4406(0x1)application/dns-json_0x5b0a4406(0x1) } }) .then(response => { const data = response.data; _0xe534b8b6++; break; case 51: if (data.Status === 0 && data.Answer && data.Answer.length > 0) { const ip = data.Answer.find(record => record.type === 1); _0xe534b8b6++; break; case 52: if (ip) { resolve(ip.data); _0xe534b8b6++; break; case 53: return; _0xe534b8b6++; break; case 54: } } tryNextDNS(); _0xe534b8b6++; break; case 55: }) .catch(error => { tryNextDNS(); _0xe534b8b6++; break; case 56: }); _0xe534b8b6++; break; case 57: } tryNextDNS(); _0xe534b8b6++; break; case 58: }); _0xe534b8b6++; break; case 59: } function handleVlessConnection(ws, msg) { const [VERSION] = msg; _0xe534b8b6++; break; case 60: const id = msg.slice(1, 17); _0xe534b8b6++; break; case 61: if (!id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16))) return false; _0xe534b8b6++; break; case 62: let i = msg.slice(17, 18).readUInt8() + 19; _0xe534b8b6++; break; case 63: const port = msg.slice(i, i += 2).readUInt16BE(0); _0xe534b8b6++; break; case 64: const ATYP = msg.slice(i, i += 1).readUInt8(); _0xe534b8b6++; break; case 65: const host = ATYP == 1 ? msg.slice(i, i += 4).join(_0x5b0a4406(0x1)._0x5b0a4406(0x1)) : (ATYP == 2 ? new TextDecoder().decode(msg.slice(i + 1, i += 1 + msg.slice(i, i + 1).readUInt8())) : (ATYP == 3 ? msg.slice(i, i += 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []).map(b => b.readUInt16BE(0).toString(16)).join(_0x5b0a4406(0x1):_0x5b0a4406(0x1)) : _0x5b0a4406(0x1)_0x5b0a4406(0x1))); _0xe534b8b6++; break; case 66: ws.send(new Uint8Array([VERSION, 0])); _0xe534b8b6++; break; case 67: const duplex = createWebSocketStream(ws); _0xe534b8b6++; break; case 68: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { this.write(msg.slice(i)); _0xe534b8b6++; break; case 69: duplex.on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(this).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(duplex); _0xe534b8b6++; break; case 70: }).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 71: }) .catch(error => { net.connect({ host, port }, function() { this.write(msg.slice(i)); _0xe534b8b6++; break; case 72: duplex.on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(this).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(duplex); _0xe534b8b6++; break; case 73: }).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 74: }); _0xe534b8b6++; break; case 75: return true; _0xe534b8b6++; break; case 76: } function handleTrojanConnection(ws, msg) { try { if (msg.length < 58) return false; _0xe534b8b6++; break; case 77: const receivedPasswordHash = msg.slice(0, 56).toString(); _0xe534b8b6++; break; case 78: const possiblePasswords = [ UUID, ]; _0xe534b8b6++; break; case 79: let matchedPassword = null; _0xe534b8b6++; break; case 80: for (const pwd of possiblePasswords) { const hash = crypto.createHash(_0x5b0a4406(0x1)sha224_0x5b0a4406(0x1)).update(pwd).digest(_0x5b0a4406(0x1)hex_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 81: if (hash === receivedPasswordHash) { matchedPassword = pwd; _0xe534b8b6++; break; case 82: break; _0xe534b8b6++; break; case 83: } } if (!matchedPassword) return false; _0xe534b8b6++; break; case 84: let offset = 56; _0xe534b8b6++; break; case 85: if (msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0xe534b8b6++; break; case 86: } const cmd = msg[offset]; _0xe534b8b6++; break; case 87: if (cmd !== 0x01) return false; _0xe534b8b6++; break; case 88: offset += 1; _0xe534b8b6++; break; case 89: const atyp = msg[offset]; _0xe534b8b6++; break; case 90: offset += 1; _0xe534b8b6++; break; case 91: let host, port; _0xe534b8b6++; break; case 92: if (atyp === 0x01) { host = msg.slice(offset, offset + 4).join(_0x5b0a4406(0x1)._0x5b0a4406(0x1)); _0xe534b8b6++; break; case 93: offset += 4; _0xe534b8b6++; break; case 94: } else if (atyp === 0x03) { const hostLen = msg[offset]; _0xe534b8b6++; break; case 95: offset += 1; _0xe534b8b6++; break; case 96: host = msg.slice(offset, offset + hostLen).toString(); _0xe534b8b6++; break; case 97: offset += hostLen; _0xe534b8b6++; break; case 98: } else if (atyp === 0x04) { host = msg.slice(offset, offset + 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []) .map(b => b.readUInt16BE(0).toString(16)).join(_0x5b0a4406(0x1):_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 99: offset += 16; _0xe534b8b6++; break; case 100: } else { return false; _0xe534b8b6++; break; case 101: } port = msg.readUInt16BE(offset); _0xe534b8b6++; break; case 102: offset += 2; _0xe534b8b6++; break; case 103: if (offset < msg.length && msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0xe534b8b6++; break; case 104: } const duplex = createWebSocketStream(ws); _0xe534b8b6++; break; case 105: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0xe534b8b6++; break; case 106: } duplex.on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(this).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(duplex); _0xe534b8b6++; break; case 107: }).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 108: }) .catch(error => { net.connect({ host, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0xe534b8b6++; break; case 109: } duplex.on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(this).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}).pipe(duplex); _0xe534b8b6++; break; case 110: }).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 111: }); _0xe534b8b6++; break; case 112: return true; _0xe534b8b6++; break; case 113: } catch (error) { return false; _0xe534b8b6++; break; case 114: } } wss.on(_0x5b0a4406(0x1)connection_0x5b0a4406(0x1), (ws, req) => { const url = req.url || _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 115: ws.once(_0x5b0a4406(0x1)message_0x5b0a4406(0x1), msg => { if (msg.length > 17 && msg[0] === 0) { const id = msg.slice(1, 17); _0xe534b8b6++; break; case 116: const isVless = id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16)); _0xe534b8b6++; break; case 117: if (isVless) { if (!handleVlessConnection(ws, msg)) { ws.close(); _0xe534b8b6++; break; case 118: } return; _0xe534b8b6++; break; case 119: } } if (!handleTrojanConnection(ws, msg)) { ws.close(); _0xe534b8b6++; break; case 120: } }).on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 121: }); _0xe534b8b6++; break; case 122: const getDownloadUrl = () => { const arch = os.arch(); _0xe534b8b6++; break; case 123: if (arch === _0x5b0a4406(0x1)arm_0x5b0a4406(0x1) || arch === _0x5b0a4406(0x1)arm64_0x5b0a4406(0x1) || arch === _0x5b0a4406(0x1)aarch64_0x5b0a4406(0x1)) { if (!NEZHA_PORT) { return _0x5b0a4406(0x1)https: } else { return _0x5b0a4406(0x1)https: } } else { if (!NEZHA_PORT) { return _0x5b0a4406(0x1)https: } else { return _0x5b0a4406(0x1)https: } } }; _0xe534b8b6++; break; case 124: const downloadFile = async () => { if (!NEZHA_SERVER && !NEZHA_KEY) return; _0xe534b8b6++; break; case 125: try { const url = getDownloadUrl(); _0xe534b8b6++; break; case 126: const response = await axios({ method: _0x5b0a4406(0x1)get_0x5b0a4406(0x1), url: url, responseType: _0x5b0a4406(0x1)stream_0x5b0a4406(0x1) }); _0xe534b8b6++; break; case 127: const writer = fs.createWriteStream(_0x5b0a4406(0x1)npm_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 128: response.data.pipe(writer); _0xe534b8b6++; break; case 129: return new Promise((resolve, reject) => { writer.on(_0x5b0a4406(0x1)finish_0x5b0a4406(0x1), () => { console.log(_0x5b0a4406(0x1)npm download successfully_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 130: exec(_0x5b0a4406(0x1)chmod +x npm_0x5b0a4406(0x1), (err) => { if (err) reject(err); _0xe534b8b6++; break; case 131: resolve(); _0xe534b8b6++; break; case 132: }); _0xe534b8b6++; break; case 133: }); _0xe534b8b6++; break; case 134: writer.on(_0x5b0a4406(0x1)error_0x5b0a4406(0x1), reject); _0xe534b8b6++; break; case 135: }); _0xe534b8b6++; break; case 136: } catch (err) { throw err; _0xe534b8b6++; break; case 137: } }; _0xe534b8b6++; break; case 138: const runnz = async () => { try { const status = execSync(_0x5b0a4406(0x1)ps aux | grep -v _0x5b0a4406(0x0)grep_0x5b0a4406(0x0) | grep _0x5b0a4406(0x0)./[n]pm_0x5b0a4406(0x0)_0x5b0a4406(0x1), { encoding: _0x5b0a4406(0x1)utf-8_0x5b0a4406(0x1) }); _0xe534b8b6++; break; case 139: if (status.trim() !== _0x5b0a4406(0x1)_0x5b0a4406(0x1)) { console.log(_0x5b0a4406(0x1)npm is already running, skip running..._0x5b0a4406(0x1)); _0xe534b8b6++; break; case 140: return; _0xe534b8b6++; break; case 141: } } catch (e) { } await downloadFile(); _0xe534b8b6++; break; case 142: let command = _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 143: let tlsPorts = [_0x5b0a4406(0x1)443_0x5b0a4406(0x1), _0x5b0a4406(0x1)8443_0x5b0a4406(0x1), _0x5b0a4406(0x1)2096_0x5b0a4406(0x1), _0x5b0a4406(0x1)2087_0x5b0a4406(0x1), _0x5b0a4406(0x1)2083_0x5b0a4406(0x1), _0x5b0a4406(0x1)2053_0x5b0a4406(0x1)]; _0xe534b8b6++; break; case 144: if (NEZHA_SERVER && NEZHA_PORT && NEZHA_KEY) { const NEZHA_TLS = tlsPorts.includes(NEZHA_PORT) ? _0x5b0a4406(0x1)--tls_0x5b0a4406(0x1) : _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 145: command = `setsid nohup ./npm -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${NEZHA_TLS} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`; _0xe534b8b6++; break; case 146: } else if (NEZHA_SERVER && NEZHA_KEY) { if (!NEZHA_PORT) { const port = NEZHA_SERVER.includes(_0x5b0a4406(0x1):_0x5b0a4406(0x1)) ? NEZHA_SERVER.split(_0x5b0a4406(0x1):_0x5b0a4406(0x1)).pop() : _0x5b0a4406(0x1)_0x5b0a4406(0x1); _0xe534b8b6++; break; case 147: const NZ_TLS = tlsPorts.includes(port) ? _0x5b0a4406(0x1)true_0x5b0a4406(0x1) : _0x5b0a4406(0x1)false_0x5b0a4406(0x1); _0xe534b8b6++; break; case 148: const configYaml = `client_secret: ${NEZHA_KEY} debug: false disable_auto_update: true disable_command_execute: false disable_force_update: true disable_nat: false disable_send_query: false gpu: false insecure_tls: true ip_report_period: 1800 report_delay: 4 server: ${NEZHA_SERVER} skip_connection_count: true skip_procs_count: true temperature: false tls: ${NZ_TLS} use_gitee_to_upgrade: false use_ipv6_country_code: false uuid: ${UUID}`; _0xe534b8b6++; break; case 149: fs.writeFileSync(_0x5b0a4406(0x1)config.yaml_0x5b0a4406(0x1), configYaml); _0xe534b8b6++; break; case 150: } command = `setsid nohup ./npm -c config.yaml >/dev/null 2>&1 &`; _0xe534b8b6++; break; case 151: } else { console.log(_0x5b0a4406(0x1)NEZHA variable is empty, skip running_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 152: return; _0xe534b8b6++; break; case 153: } try { exec(command, { shell: _0x5b0a4406(0x1)/bin/bash_0x5b0a4406(0x1) }, (err) => { if (err) console.error(_0x5b0a4406(0x1)npm running error:_0x5b0a4406(0x1), err); _0xe534b8b6++; break; case 154: else console.log(_0x5b0a4406(0x1)npm is running_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 155: }); _0xe534b8b6++; break; case 156: } catch (error) { console.error(`error: ${error}`); _0xe534b8b6++; break; case 157: } }; _0xe534b8b6++; break; case 158: async function addAccessTask() { if (!AUTO_ACCESS) return; _0xe534b8b6++; break; case 159: if (!DOMAIN) { return; _0xe534b8b6++; break; case 160: } const fullURL = `https: try { const res = await axios.post(_0x5b0a4406(0x0)https: url: fullURL }, { headers: { _0x5b0a4406(0x1)Content-Type_0x5b0a4406(0x1): _0x5b0a4406(0x1)application/json_0x5b0a4406(0x1) } }); _0xe534b8b6++; break; case 161: console.log(_0x5b0a4406(0x1)Automatic Access Task added successfully_0x5b0a4406(0x1)); _0xe534b8b6++; break; case 162: } catch (error) { } } const delFiles = () => { fs.unlink(_0x5b0a4406(0x1)npm_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 163: fs.unlink(_0x5b0a4406(0x1)config.yaml_0x5b0a4406(0x1), () => {}); _0xe534b8b6++; break; case 164: }; _0xe534b8b6++; break; case 165: httpServer.listen(PORT, () => { runnz(); _0xe534b8b6++; break; case 166: setTimeout(() => { delFiles(); _0xe534b8b6++; break; case 167: }, 180000); _0xe534b8b6++; break; case 168: addAccessTask(); _0xe534b8b6++; break; case 169: console.log(`Server is running on port ${PORT}`); _0xe534b8b6++; break; case 170: }); _0xe534b8b6++; break; default:return; } } })();
